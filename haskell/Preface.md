---
layout: page
published: true
---
## Funktionale Programmierung mit Haskell

Ich habe vor (sehen wir mal wie weit ich komme) meine Erkenntnisse über funktionale Programmierung mit Haskell in einer Reihe von Posts zusammenzufassen. 

Dabei sind mir zwei Dinge wichtig:

1. die Grundidee verstehen
1. die Dinge von der pragmatischen Seite aus zu betrachten
  
Das bedeutet, dass ich zugunsten meines Verständnisses erstens nicht immer alles vollständig betrachte, und ich - wenn auch später wichtige - mathematische Erkenntnisse erst einmal komplett ignoriere. So werde ich anfangs z.B. nicht alle Arten neue Typen zu definieren behandeln, sondern nur die, die mir beim Verständnis funktionaler Programmierung helfen. Auch kümmert es mich erst einmal nicht, dass eine Monade ein Monoid in der Kategorie der Endofunktoren ist, oder welche Regeln ein Functor erfüllen muss. Ich will wissen wozu sie gut sind und wann ich sie wo, warum einsetze. Ja, die mathematische Natur von Haskell ist ein wichtiger Aspekt der für die Sprache spricht, steht mir beim Lernen aber eher im Weg.

1. [FP vs OO](/haskell/fp-vs-oo)
1. [Funktionen](/haskell/Funktionen)
1. [Datentypen / Mengen](/haskell/Datentypen)
1. [Funktionen als Werte](/haskell/Funktionen-als-Werte)
1. [Komposition von Funktionen](/haskell/Komposition-Funktionen)
1. Kontrollstrukturen
1. [Patterns](/haskell/Patterns)
    1. [Functor](/haskell/Patterns-Functor)
    1. [Applicative](/haskell/Patterns-Applicative)
    1. [Monad](/haskell/Patterns-Monad)
    1. [Komposition bei Functor, Applicative und Monad](/haskell/Komposition-Patterns)
    1. [Do Notation bei Monaden](/haskell/Patterns-Do)
    1. Traversable
    1. [Record und Lens](/haskell/Records-Lenses)
    1. Monad Transformers
    1. Effects
1. [Haskell und Lazy Evaluation](/haskell/Lazy)
1. Seiteneffekte
    1. Ein-/Ausgabe
    1. Variablen
    1. Concurrency
1. deriving
1. Type Aliase und newtype

